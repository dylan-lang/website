<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
  <head>
    
    <!-- Relative Navigation -->
    
    <link rel="up" href="Macros" />
    <link rel="prev" href="Hygiene" />
    <link rel="next" href="Built-In_Classes" />
    
    <!-- Absolute Navigation -->
    
    <link rel="top" href="Title" />
    <link rel="start first" href="." />
    <link rel="copyright" href="Copyrights" />
    <link rel="contents" href="Contents" />
    <link rel="glossary" href="Glossary" />
    <link rel="index" href="Index" />
    <link rel="last author" href="Colophon" />
    
    <!-- Chapters -->
    
    <link rel="chapter" title="About This Book" href="Preface" />
    <link rel="chapter" title="1 Introduction" href="Introduction" />
    <link rel="chapter" title="2 Syntax" href="Syntax" />
    <link rel="chapter" title="3 Program Structure" href="Program_Structure" />
    <link rel="chapter" title="4 Program Control" href="Program_Control" />
    <link rel="chapter" title="5 Types and Classes" href="Types_and_Classes" />
    <link rel="chapter" title="6 Functions" href="Functions" />
    <link rel="chapter" title="7 Conditions" href="Conditions" />
    <link rel="chapter" title="8 Collections" href="Collections" />
    <link rel="chapter" title="9 Sealing" href="Sealing" />
    <link rel="chapter" title="10 Macros" href="Macros" />
    <link rel="chapter" title="11 The Built-In Classes" href="Built-In_Classes" />
    <link rel="chapter" title="12 The Built-In Functions" href="Built-In_Functions" />
    <link rel="chapter" title="13 Other Built-In Objects" href="Other_Built-In_Objects" />
    <link rel="chapter" title="14 The Built-In Macros and Special Definitions" href="Built-In_Macros_and_Special_Definitions" />
    
    <!-- Appendices -->
    
    <link rel="appendix" title="A BNF" href="BNF" />
    <link rel="appendix" title="B Exported Names" href="Exported_Names" />
    
    <!-- Stylesheets -->
    
    <link rel="stylesheet" href="styles/common.css" type="text/css" />
    <link rel="stylesheet" href="styles/nav-top-fixed.css" type="text/css" media="handheld" />
    <link rel="stylesheet" href="styles/nav-left-fixed.css" type="text/css" media="screen" title="Navigation at Left" />
    <link rel="stylesheet alternate" href="styles/nav-top-fixed.css" type="text/css" media="screen" title="Navigation at Top" />

    <title>Rewrite Rule Examples &mdash; 10. Macros &mdash; The DRM</title>
  </head>
  <body class="content">

    <div id="header">
      <div id="navigation-header">
	<div id="navigation-top">
	  <div class="background">
	    <p id="book-title">
	    <img class="book-icon" alt="" src="images/color-square-small.png" width="22" height="21" />
	    <a href="Title"><img class="book-title" alt="The Dylan Reference Manual" src="images/book-title.png" width="343" height="28" /></a>
	  </p>
	  <p id="navigation-core">
	    <a class="previous" accesskey="p" title="Previous Page" href="Hygiene"><span>&larr; Previous</span></a>
	    <a class="next" accesskey="n" title="Next Page" href="Built-In_Classes"><span>Next Page &rarr;</span></a>
	    <a class="up" accesskey="u" title="Chapter Start" href="Macros"><span>Up</span></a>
	    <a class="start" accesskey="s" title="Start of Book" href="Title"><span>Start</span></a>
	    <a class="contents" accesskey="c" title="Contents" href="Contents"><span>Contents</span></a>
	    <a class="index" accesskey="i" title="Index" href="Index"><span>Index</span></a>
	  </p>
	</div>
	</div>
	<div id="navigation-TOC">
	  <ul class="front-matter">
	    <li id="book-start"><a href="Title">Start</a></li>
	    <li><a href="Contents">Contents</a></li>
	    <li><a href="Preface">About This Book</a></li>
	  </ul>
	  <ol class="chapters">
	    <li><a href="Introduction">Introduction</a></li>
	    <li><a href="Syntax">Syntax</a></li>
	    <li><a href="Program_Structure">Program Structure</a></li>
	    <li><a href="Program_Control">Program Control</a></li>
	    <li><a href="Types_and_Classes">Types and Classes</a></li>
	    <li><a href="Functions">Functions</a></li>
	    <li><a href="Conditions">Conditions</a></li>
	    <li><a href="Collections">Collections</a></li>
	    <li><a href="Sealing">Sealing</a></li>
	    <li class="current parent"><a href="Macros">Macros</a>
	      <ul class="sections">
		<li><a href="Macros_Overview">Overview</a></li>
		<li><a href="Extensible_Grammar">Extensible Grammar</a></li>
		<li><a href="Macro_Names">Macro Names</a></li>
		<li><a href="Rewrite_Rules">Rewrite Rules</a></li>
		<li><a href="Patterns">Patterns</a></li>
		<li><a href="Pattern_Variable_Constraints">Pattern Variable Constraints</a></li>
		<li><a href="Templates">Templates</a></li>
		<li><a href="Auxiliary_Rule_Sets">Auxiliary Rule Sets</a></li>
		<li><a href="Hygiene">Hygiene</a></li>
		<li id="current" class="subsections"><a href="Rewrite_Rule_Examples">Rewrite Rule Examples</a>
		  <ul class="page-TOC">
		    <li class="subsections"><a href="#HEADING-86-3">Statement Macros</a>
		      <ul>
			<li><a href="#HEADING-86-4">Begin</a></li>
			<li><a href="#HEADING-86-6">Block</a></li>
			<li><a href="#HEADING-86-11">Case</a></li>
			<li><a href="#HEADING-86-13">For</a></li>
			<li><a href="#HEADING-86-30">If</a></li>
			<li><a href="#HEADING-86-32">Method</a></li>
			<li><a href="#HEADING-86-34">Select</a></li>
			<li><a href="#HEADING-86-40">Unless</a></li>
			<li><a href="#HEADING-86-42">Until</a></li>
			<li><a href="#HEADING-86-44">While</a></li>
		      </ul>
		    </li>
		    <li class="subsections"><a href="#HEADING-86-46">Definition Macros</a>
		      <ul>
			<li><a href="#HEADING-86-47">Define Class</a></li>
			<li><a href="#HEADING-86-51">Define Constant</a></li>
			<li><a href="#HEADING-86-53">Define Domain</a></li>
			<li><a href="#HEADING-86-56">Define Generic</a></li>
			<li><a href="#HEADING-86-59">Define Library</a></li>
			<li><a href="#HEADING-86-63">Define Method</a></li>
			<li><a href="#HEADING-86-65">Define Module</a></li>
			<li><a href="#HEADING-86-69">Define Variable</a></li>
		      </ul>
		    </li>
		    <li class="subsections"><a href="#HEADING-86-71">Operator Function Macros</a>
		      <ul>
			<li><a href="#HEADING-86-72">&amp;</a></li>
			<li><a href="#HEADING-86-74">|</a></li>
			<li><a href="#HEADING-86-76">:=</a></li>
		      </ul>
		    </li>
		    <li class="subsections"><a href="#HEADING-86-78">Additional Examples</a>
		      <ul>
			<li><a href="#HEADING-86-80">Test and Test-setter</a></li>
			<li><a href="#HEADING-86-84">Transform!</a></li>
			<li><a href="#HEADING-86-87">Formatting-table</a></li>
			<li><a href="#HEADING-86-90">With-input-context</a></li>
			<li><a href="#HEADING-86-95">Define Command</a></li>
			<li><a href="#HEADING-86-107">Get-resource</a></li>
			<li><a href="#HEADING-86-110">Completing-from-suggestions</a></li>
			<li><a href="#HEADING-86-113">Define Jump-instruction</a></li>
		      </ul>
		    </li>
		  </ul>
		</li>
	      </ul>
	    </li>
	    <li><a href="Built-In_Classes">The Built-In Classes</a></li>
	    <li><a href="Built-In_Functions">The Built-In Functions</a></li>
	    <li><a href="Other_Built-In_Objects">Other Built-In Objects</a></li>
	    <li><a href="Built-In_Macros_and_Special_Definitions">The Built-In Macros and Special Definitions</a></li>
	  </ol>
	  <ol class="appendices">
	    <li><a href="BNF">BNF</a></li>
	    <li><a href="Exported_Names">Exported Names</a></li>
	  </ol>
	  <ul class="back-matter">
	    <li><a href="Glossary">Glossary</a></li>
	    <li><a href="Index">Index</a></li>
	    <li><a href="Colophon">Colophon</a></li>
	  </ul>
	  <ul class="errata">
	    <li><a href="Errata">Errata</a></li>
	  </ul>
	</div>
      </div>

      <hr />

    </div>

    <div id="content">
      <div id="section-header">
	<p id="section-prefix">Chapter 10</p>
	<p id="section-name">Macros</p>
      </div>

      <a name="HEADING-86-0"></a>
      <a name="UID-Macros-6935"></a>
      <h1 class="section-title"><a name="IX-1281">Rewrite Rule Examples</a></h1>
      <p>The following definitions of all of the built-in macros are provided as examples. This
	section is not intended to be a tutorial on how to write macros, just a collection of
	demonstrations of some of the tricks.</p>
      <p>The built-in macros cannot really be implemented this way; for example <code>if</code>
	and <code>case</code> cannot really both be implemented by expanding to the other. Certain
	built-in macros cannot be implemented with rewrite rules or necessarily rewrite into
	implementation-dependent code; in these cases the right-hand sides are shown
	as <var>id</var>.</p>
      <a name="HEADING-86-3"></a>
      <a name="UID-Macros-6941"></a>
      <h2 class="subsection-title">Statement Macros</h2>
      <a name="HEADING-86-4"></a>
      <h3 class="sub-subsection-title"><a name="IX-1282">Begin</a></h3>
      <pre class="code">
define macro begin
  { begin ?:body end } =&gt; { ?body }
end;
</pre>
      <a name="HEADING-86-6"></a>
      <h3 class="sub-subsection-title"><a name="IX-1283">Block</a></h3>
      <pre class="code">
define macro block
  { block () ?ebody end }
   =&gt; { ?ebody }
  { block (?:name) ?ebody end }
   =&gt; { with-exit(method(?name) ?ebody end) }
 // Left-recursive so leftmost clause is innermost
 ebody:
  { ... exception (?type:expression, ?eoptions) ?:body }
   =&gt; { with-handler(method() ... end,
                     method(ignore) ?body end,
                     ?type, ?eoptions) }
  { ... exception (?:name :: ?type:expression, ?eoptions) ?:body }
   =&gt; { with-handler(method() ... end,
                     method(?name) ?body end,
                     ?type, ?eoptions) }
  { ?abody cleanup ?cleanup:body}
   =&gt; { with-cleanup(method() ?abody end, method () ?cleanup end) }
  { ?abody }
   =&gt; { ?abody }
 abody:
  { ?main:body }
   =&gt; { ?main }
  { ?main:body afterwards ?after:body }
   =&gt; { with-afterwards(method() ?main end, method () ?after end) }
 eoptions:
  { #rest ?options:expression, 
    #key ?test:expression = always(#t),
    ?init-arguments:expression = #() }
   =&gt; { ?options }
end;
</pre>
      <a name="HEADING-86-11"></a>
      <h3 class="sub-subsection-title"><a name="IX-1284">Case</a></h3>
      <pre class="code">
define macro case
  { case ?:case-body end }            =&gt; { ?case-body }
 case-body:
  { }                                 =&gt; { #f }
  { otherwise ?:body }                =&gt; { ?body }
  { ?test:expression =&gt; ?:body; ... } =&gt; { if (?test) ?body
                                           else ... end if }
end;
</pre>
      <a name="HEADING-86-13"></a>
      <h3 class="sub-subsection-title"><a name="IX-1285">For</a></h3>
      <pre class="code">
// This macro has three auxiliary macros, whose definitions follow
define macro for
 { for (?header) ?fbody end }       =&gt; { for-aux ?fbody, ?header end }
 // pass main body and finally body as two expressions
 fbody:
  { ?main:body }                     =&gt; { ?main, #f }
  { ?main:body finally ?val:body }   =&gt; { ?main, ?val }
 // convert iteration clauses to property list via for-clause macro
 header:
  { ?v:variable in ?c:expression, ... }
   =&gt; { for-clause(?v in ?c) ... }
  { ?v:variable = ?e1:expression then ?e2:expression, ... }
   =&gt; { for-clause(?v = ?e1 then ?e2) ... }
  { ?v:variable from ?e1:expression ?to, ... }
   =&gt; { for-clause(?v from ?e1 ?to) ... }
  { }                                =&gt; { }
  { #key ?while:expression }         =&gt; { for-clause(~?while stop) }
  { #key ?until:expression }         =&gt; { for-clause(?until stop) }
 // parse the various forms of numeric iteration clause
 to:
  { to ?limit:expression by ?step:expression }
                                     =&gt; { hard ?limit ?step }
  { to ?limit:expression }           =&gt; { easy ?limit 1   &gt; }
  { above ?limit:expression ?by }    =&gt; { easy ?limit ?by &lt;= }
  { below ?limit:expression ?by }    =&gt; { easy ?limit ?by &gt;= }
  { ?by }                            =&gt; { loop ?by }
 by:
  { }                                =&gt; { 1 }
  { by ?step:expression }            =&gt; { ?step }
end;
// Auxiliary macro to make the property list for an iteration clause.
// Each iteration clause is a separate call to this macro so the
// hygiene rules will keep the temporary variables for each clause
// distinct.
// The properties are:
//  init0: - constituents for start of body, outside the loop
//  var1:  - a variable to bind on each iteration
//  init1: - initial value for that variable
//  next1: - value for that variable on iterations after the first
//  stop1: - test expression, stop if true, after binding var1's
//  var2:  - a variable to bind on each iteration, after stop1 tests
//  next2: - value for that variable on every iteration
//  stop2: - test expression, stop if true, after binding var2's
define macro for-clause
  // while:/until: clause
  { for-clause(?e:expression stop) }
   =&gt; { , stop2: ?e }
  // Explicit step clause
  { for-clause(?v:variable = ?e1:expression then ?e2:expression) }
   =&gt; { , var1: ?v, init1: ?e1, next1: ?e2 }
  // Collection clause
  { for-clause(?v:variable in ?c:expression) }
   =&gt; { , init0: [ let collection = ?c;
                   let (initial-state, limit,
                        next-state, finished-state?,
                        current-key, current-element)
                       = forward-iteration-protocol(collection); ]
        , var1: state, init1: initial-state
        , next1: next-state(collection, state)
        , stop1: finished-state?(collection, state, limit)
       , var2: ?v, next2: current-element(collection, state) }
  // Numeric clause (three cases depending on ?to right-hand side)
  { for-clause(?v:name :: ?t:expression from ?e1:expression
               loop ?by:expression) }
   =&gt; { , init0: [ let init = ?e1;
                   let by = ?by; ]
        , var1: ?v :: ?t, init1: init, next1: ?v + by }
  { for-clause(?v:name :: ?t:expression from ?e1:expression
               easy ?limit:expression ?by:expression ?test:token) }
   =&gt; { , init0: [ let init = ?e1;
                   let limit = ?limit;
                   let by = ?by; ]
        , var1: ?v :: ?t, init1: init, next1: ?v + by
        , stop1: ?v ?test limit }
  { for-clause(?v:name :: ?t:expression from ?e1:expression
               hard ?limit:expression ?by:expression) }
   =&gt; { , init0: [ let init = ?e1;
                   let limit = ?limit;
                   let by = ?by; ]
        , var1: ?v :: ?t, init1: init, next1: ?v + by
        , stop1: if (by &gt;= 0) ?v &gt; limit else ?v &lt; limit end if }
end;
// Auxiliary macro to expand multiple for-clause macros and
// concatenate their expansions into a single property list.
define macro for-aux
  { for-aux ?main:expression, ?value:expression, ?clauses:* end }
   =&gt; { for-aux2 ?main, ?value ?clauses end }
 clauses:
  { } =&gt; { }
  { ?clause:macro ... } =&gt; { ?clause ... }
end;
// Auxiliary macro to assemble collected stuff into a loop.
// Tricky points:
// loop iterates by tail-calling itself.
// return puts the finally clause into the correct lexical scope.
// ??init0 needs an auxiliary rule set to strip off the shielding
// brackets that make it possible to stash local declarations in
// a property list.
// ??var2 and ??next2 need a default because let doesn't allow
// an empty variable list.
// ??stop1 and ??stop2 need a default because if () is invalid.
define macro for-aux2
  { for-aux2 ?main:expression, ?value:expression,
             #key ??init0:*, ??var1:variable,
                  ??init1:expression, ??next1:expression,
                  ??stop1:expression = #f,
                  ??var2:variable = x, ??next2:expression = 0,
                  ??stop2:expression = #f
    end }
   =&gt; { ??init0 ...
        local method loop(??var1, ...)
                let return = method() ?value end method;
                if (??stop1 | ...) return()
                else let (??var2, ...) = values(??next2, ...);
                     if(??stop2 | ...) return()
                     else ?main; loop(??next1, ...)
                     end if;
                end if;
              end method;
        loop(??init1, ...) }
 // strip off brackets used only for grouping
 init0:
  { [ ?stuff:* ] } =&gt; { ?stuff }
end;
</pre>
      <a name="HEADING-86-30"></a>
      <h3 class="sub-subsection-title"><a name="IX-1286">If</a></h3>
      <pre class="code">
define macro if
  { if (?test:expression) ?:body ?elses end }
                                     =&gt; { case ?test =&gt; ?body;
                                          otherwise ?elses end }
 elses:
  { }                                =&gt; { #f }
  { else ?:body }                    =&gt; { ?body }
  { elseif (?test:expression) ?:body ... }
                                     =&gt; { case ?test =&gt; ?body;
                                          otherwise ... end }
end;
</pre>
      <a name="HEADING-86-32"></a>
      <h3 class="sub-subsection-title"><a name="IX-1287">Method</a></h3>
      <pre class="code">
define macro method
  { method (?parameters:*) =&gt; (?results:*) ; ?:body end }     =&gt;  <var>id</var>
  { method (?parameters:*) =&gt; (?results:*) ?:body end }       =&gt;  <var>id</var>
  { method (?parameters:*) =&gt; ?result:variable ; ?:body end } =&gt;  <var>id</var>
  { method (?parameters:*) ; ?:body end }                     =&gt;  <var>id</var>
  { method (?parameters:*) ?:body end }                       =&gt;  <var>id</var>
end;
</pre>
      <a name="HEADING-86-34"></a>
      <h3 class="sub-subsection-title"><a name="IX-1288">Select</a></h3>
      <pre class="code">
define macro select
  { select (?what) ?:case-body end } =&gt; { ?what; ?case-body }
 what:
  { ?object:expression by ?compare:expression }
                                    =&gt;  { let object = ?object;
                                          let compare = ?compare }
  { ?object:expression }            =&gt;  { let object = ?object;
                                          let compare = \== }
 case-body:
  { }
   =&gt; { error("select error, %= doesn't match any key", object) }
  { otherwise ?:body }              =&gt; { ?body }
  { ?keys =&gt; ?:body; ... }          =&gt; { if (?keys) ?body
                                         else ... end if }
 keys:
  { ?key:expression }               =&gt; { compare(object, ?key) }
  { (?keys2) }                      =&gt; { ?keys2 }
  { ?keys2 }                        =&gt; { ?keys2 }
 keys2:
  { ?key:expression }               =&gt; { compare(object, ?key) }
  { ?key:expression, ... }          =&gt; { compare(object, ?key) | ... }
end;
</pre>
      <a name="HEADING-86-40"></a>
      <h3 class="sub-subsection-title"><a name="IX-1289">Unless</a></h3>
      <pre class="code">
define macro unless
  { unless (?test:expression) ?:body end }
   =&gt; { if (~ ?test) ?body end }
end;
</pre>
      <a name="HEADING-86-42"></a>
      <h3 class="sub-subsection-title"><a name="IX-1290">Until</a></h3>
      <pre class="code">
define macro until
  { until (?test:expression) ?:body end }
   =&gt; { local method loop ()
                if (~ ?test)
                  ?body;
                  loop()
                end if;
              end method;
        loop() }
end;
</pre>
      <a name="HEADING-86-44"></a>
      <h3 class="sub-subsection-title"><a name="IX-1291">While</a></h3>
      <pre class="code">
define macro while
  { while (?test:expression) ?:body end }
   =&gt; { local method loop ()
                if (?test)
                  ?body;
                  loop()
                end if;
              end method;
        loop() }
end;
</pre>
      <a name="HEADING-86-46"></a>
      <a name="UID-Macros-7223"></a>
      <h2 class="subsection-title">Definition Macros</h2>
      <a name="HEADING-86-47"></a>
      <h3 class="sub-subsection-title"><a name="IX-1292">Define Class</a></h3>
      <pre class="code">
define macro class-definer
  { define ?mods:* class ?:name (?supers) ?slots end }  =&gt;  <var>id</var>
 supers:
  { }                                                   =&gt;  <var>id</var>
  { ?super:expression, ... }                            =&gt;  <var>id</var>
 slots:
  { }                                                   =&gt;  <var>id</var>
  { inherited slot ?:name, #rest ?options:*; ... }      =&gt;  <var>id</var>
  { inherited slot ?:name = ?init:expression,
    #rest ?options:*; ... }                             =&gt;  <var>id</var>
  { ?mods:* slot ?:name, #rest ?options:*; ... }        =&gt;  <var>id</var>
  { ?mods:* slot ?:name = ?init:expression,
    #rest ?options:*; ... }                             =&gt;  <var>id</var>
  { ?mods:* slot ?:name :: ?type:expression,
    #rest ?options:*; ... }                             =&gt;  <var>id</var>
  { ?mods:* slot ?:name :: ?type:expression = ?init:expression,
    #rest ?options:*; ... }                             =&gt;  <var>id</var>
  { required keyword ?key:expression,
    #rest ?options:*; ... }                             =&gt;  <var>id</var>
  { required keyword ?key:expression ?equals:token ?init:expression,
    #rest ?options:*; ... }                             =&gt;  <var>id</var>
  { keyword ?key:expression, #rest ?options:*; ... }    =&gt;  <var>id</var>
  { keyword ?key:expression ?equals:token ?init:expression,
    #rest ?options:*; ... }                             =&gt;  <var>id</var>
end;
</pre>
      <a name="HEADING-86-51"></a>
      <h3 class="sub-subsection-title"><a name="IX-1293">Define Constant</a></h3>
      <pre class="code">
define macro constant-definer
  { define ?modifiers:* constant
    ?:name :: ?type:expression = ?init:expression }     =&gt;  <var>id</var>
  { define ?modifiers:* constant
    (?variables:*) ?equals:token ?init:expression }     =&gt;  <var>id</var>
end;
</pre>
      <a name="HEADING-86-53"></a>
      <h3 class="sub-subsection-title"><a name="IX-1294">Define Domain</a></h3>
      <pre class="code">
define macro domain-definer
  { define sealed domain ?:name ( ?types ) }            =&gt;  <var>id</var>
 types:
  { } =&gt; { }
  { ?type:expression, ... } =&gt; { ?type, ... }
end;
</pre>
      <a name="HEADING-86-56"></a>
      <h3 class="sub-subsection-title"><a name="IX-1295">Define Generic</a></h3>
      <pre class="code">
define macro generic-definer
  { define ?mods:* generic ?:name ?rest:* }             =&gt;  <var>id</var>
 rest:
  { ( ?parameters:* ), #key }                           =&gt;  <var>id</var>
  { ( ?parameters:* ) =&gt; ?:variable, #key }             =&gt;  <var>id</var>
  { ( ?parameters:* ) =&gt; (?variables:*), #key }         =&gt;  <var>id</var>
end;
</pre>
      <a name="HEADING-86-59"></a>
      <h3 class="sub-subsection-title"><a name="IX-1296">Define Library</a></h3>
      <pre class="code">
define macro library-definer
  { define library ?:name ?items end }                  =&gt;  <var>id</var>
 items:
  { }                                                   =&gt;  <var>id</var>
  { use ?:name, #rest ?options:*; ... }                 =&gt;  <var>id</var>
  { export ?names; ... }                                =&gt;  <var>id</var>
 names:
  { ?:name }                                            =&gt;  <var>id</var>
  { ?:name, ... }                                       =&gt;  <var>id</var>
end;
</pre>
      <a name="HEADING-86-63"></a>
      <h3 class="sub-subsection-title"><a name="IX-1297">Define Method</a></h3>
      <pre class="code">
define macro method-definer
  { define ?mods:* method ?:name ?rest end }            =&gt;  <var>id</var>
 rest:
  { (?parameters:*) =&gt; (?results:*) ; ?:body }          =&gt;  <var>id</var>
  { (?parameters:*) =&gt; (?results:*) ?:body }            =&gt;  <var>id</var>
  { (?parameters:*) =&gt; ?result:variable ; ?:body }      =&gt;  <var>id</var>
  { (?parameters:*) ; ?:body }                          =&gt;  <var>id</var>
  { (?parameters:*) ?:body }                            =&gt;  <var>id</var>
end;
</pre>
      <a name="HEADING-86-65"></a>
      <h3 class="sub-subsection-title"><a name="IX-1298">Define Module</a></h3>
      <pre class="code">
define macro module-definer
  { define module ?:name ?items end }                   =&gt;  <var>id</var>
 items:
  { }                                                   =&gt;  <var>id</var>
  { use ?:name, #rest ?options:*; ... }                 =&gt;  <var>id</var>
  { export ?names; ... }                                =&gt;  <var>id</var>
  { create ?names; ... }                                =&gt;  <var>id</var>
 names:
  { ?:name }                                            =&gt;  <var>id</var>
  { ?:name, ... }                                       =&gt;  <var>id</var>
end;
</pre>
      <a name="HEADING-86-69"></a>
      <h3 class="sub-subsection-title"><a name="IX-1299">Define Variable</a></h3>
      <pre class="code">
define macro variable-definer
  { define ?modifiers:* variable
    ?:name :: ?type:expression = ?init:expression }     =&gt;  <var>id</var>
  { define ?modifiers:* variable
    (?variables:*) ?equals:token ?init:expression }     =&gt;  <var>id</var>
end;
</pre>
      <a name="HEADING-86-71"></a>
      <a name="UID-Macros-7337"></a>
      <h2 class="subsection-title">Operator Function Macros</h2>
      <a name="HEADING-86-72"></a>
      <h3 class="sub-subsection-title"><a name="IX-1300">&amp;</a></h3>
      <pre class="code">
define macro \&amp;
  { \&amp;(?first:expression, ?second:expression) }
   =&gt; { if (?first) ?second else #f end }
end;
</pre>
      <a name="HEADING-86-74"></a>
      <h3 class="sub-subsection-title"><a name="IX-1301">|</a></h3>
      <pre class="code">
define macro \|
  { \|(?first:expression, ?second:expression) }
   =&gt; { let temp = ?first;
        if (temp) temp else ?second end }
end;
</pre>
      <a name="HEADING-86-76"></a>
      <h3 class="sub-subsection-title"><a name="IX-1302">:=</a></h3>
      <pre class="code">
define macro \:=
  { \:=(?place:macro, ?value:expression) }              =&gt;  <var>id</var>
  { \:=(?place:expression, ?value:expression) }         =&gt;  <var>id</var>
end;<a name="IX-1303"></a>
</pre>
      <a name="HEADING-86-78"></a>
      <a name="UID-Macros-7361"></a>
      <h2 class="subsection-title">Additional Examples</h2>
      <p>The following macros are not built-in, but are simply supplied as examples. Each is shown
	as a definition followed by a sample call.</p>
      <a name="HEADING-86-80"></a>
      <h3 class="sub-subsection-title">Test and Test-setter</h3>
      <pre class="code">
define macro test
  { test(?object:expression) }
   =&gt; { frame-slot-getter(?object, #"test") }
end macro;
define macro test-setter
  { test-setter(?value:expression, ?object:expression) }
   =&gt; { frame-slot-setter(?value, ?object, #"test") }
end macro;
test(foo.bar) := foo.baz;
</pre>
      <a name="HEADING-86-84"></a>
      <h3 class="sub-subsection-title">Transform!</h3>
      <pre class="code">
define macro transform!
 // base case
 { transform!(?xform:expression) } =&gt; { ?xform }
 // the main recursive rule
 { transform!(?xform:expression, ?x:expression, ?y:expression,
              ?more:*) }
  =&gt; { let xform = ?xform;
       let (nx, ny) = transform(xform, ?x, ?y);
       ?x := nx; ?y := ny;
       transform!(xform, ?more) }
end macro;
transform!(w.transformation, xvar, yvar, w.pos.x, w.pos.y);
</pre>
      <a name="HEADING-86-87"></a>
      <h3 class="sub-subsection-title">Formatting-table</h3>
      <pre class="code">
define macro formatting-table
  { formatting-table (?:expression,
                      #rest ?options:expression,
                      #key ?x-spacing:expression = 0,
                           ?y-spacing:expression = 0)
      ?:body end }
   =&gt; { do-formatting-table(?expression, method() ?body end,
                            ?options) }
end macro;
formatting-table (stream, x-spacing: 10, y-spacing: 12)
  foobar(stream)
end;
</pre>
      <a name="HEADING-86-90"></a>
      <h3 class="sub-subsection-title">With-input-context</h3>
      <pre class="code">
define macro with-input-context
  { with-input-context (?context-type:expression,
                        #key ?override:expression = #f)
     ?bbody end }
   =&gt; { do-with-input-context(?context-type, ?bbody,
                              override: ?override) }
 bbody:
  { ?:body ?clauses }  =&gt; { list(?clauses), method() ?body end }
 clauses:
  { }                  =&gt; { }
  { on (?:name :: ?spec:expression, ?type:variable) ?:body ... }
   =&gt; { pair(?spec, method (?name :: ?spec, ?type) ?body end),
        ... }
end macro;
with-input-context (context-type, override: #t)
      // the body that reads from the user
      read-command-or-form (stream);
    // the clauses that dispatch on the type
    on (object :: &lt;command&gt;, type) execute-command (object);
    on (object :: &lt;form&gt;, type) evaluate-form (object, type);
end;
</pre>
      <a name="HEADING-86-95"></a>
      <h3 class="sub-subsection-title">Define Command</h3>
      <pre class="code">
define macro command-definer
 { define command ?:name (?arguments:*) (#rest ?options:expression)
     ?:body end }
  =&gt; { define-command-1 ?name (?arguments) ?body end;
       define-command-2 ?name (?arguments) (?options) end }
end macro;
// define the method that implements a command
// throws away the "stuff" in each argument used by the command parser
define macro define-command-1
 { define-command-1 ?:name (?arguments) ?:body end }
  =&gt; { define method ?name (?arguments) ?body end }
 // map over ?arguments, reducing each to a parameter-list entry
 // but when we get to the first argument that has a default, put
 // in #key and switch to the key-arguments loop
 arguments:
  { } =&gt; { }
  { ?:variable = ?default:expression ?stuff:*, ?key-arguments }
   =&gt; { #key ?variable = ?default, ?key-arguments }
  { ?argument, ... } =&gt; { ?argument, ... }
 // map over keyword arguments the same way, each must
 // have a default
 key-arguments:
  { } =&gt; { }
  { ?key-argument, ... } =&gt; { ?key-argument, ... }
 // reduce one required argument spec to a parameter-list entry
 argument:
  { ?:variable ?stuff:* } =&gt; { ?variable }
 // reduce one keyword argument spec to a parameter-list entry
 key-argument:
  { ?:variable = ?default:expression ?stuff:* }
   =&gt; { ?variable = ?default }
end macro;
// generate the datum that describes a command and install it
define macro define-command-2
 { define-command-2 ?:name (?arguments) (#rest ?options:*) end }
  =&gt; { install-command(?name, list(?arguments), ?options) }
 // map over ?arguments, reducing each to a data structure
 arguments:
  { } =&gt; { }
  { ?argument, ... } =&gt; { ?argument, ... }
 // reduce one argument specification to a data structure
 argument:
  { ?:name :: ?type:expression = ?default:expression ?details }
   =&gt; { make(&lt;argument-info&gt;, name: ?"name", type: ?type,
             default: ?default, ?details) }
  { ?:name :: ?type:expression ?details }
   =&gt; { make(&lt;argument-info&gt;, name: ?"name", type: ?type, ?details) }
 // translate argument specification to &lt;argument-info&gt; init keywords
 details:
  { } =&gt; { }
  { ?key:name ?value:expression ... } =&gt; { ?#"key" ?value, ... }
end macro;
define command com-show-home-directory
       (directory :: &lt;type&gt; provide-default #t,
        before :: &lt;time&gt; = #() prompt "date",
        after  :: &lt;time&gt; = #() prompt "date")
       // Options
       (command-table: directories,
        name: "Show Home Directory")
    body()
end command com-show-home-directory;
</pre>
      <a name="HEADING-86-107"></a>
      <h3 class="sub-subsection-title">Get-resource</h3>
      <pre class="code">
// The idea is that in this application each library has its own
// variable named $library, which is accessible to modules in that
// library. Get-resource gets a resource associated with the library
// containing the call to it. Get-resource-from-library is a function.
// The get-resource macro is a device to make programs more concise.
define macro get-resource
  { get-resource(?type:expression, ?id:expression) }
   =&gt; { get-resource-from-library(?=$library, ?type, ?id) }
end macro;
show-icon(get-resource(ResType("ICON"), 1044));
</pre>
      <a name="HEADING-86-110"></a>
      <h3 class="sub-subsection-title">Completing-from-suggestions</h3>
      <pre class="code">
// The completing-from-suggestions macro defines a lexically visible
// helper function called "suggest," which is only meaningful inside
// of calls to the completer. The "suggest" function is passed as an
// argument to the method passed to complete-input; alternatively it
// could have been defined in a local declaration wrapped around the
// method.
define macro completing-from-suggestions
  { completing-from-suggestions (?stream:expression,
                                 #rest ?options:expression)
      ?:body end }
   =&gt;{ complete-input(?stream,
                      method (?=suggest) ?body end,
                      ?options) }
end macro;
completing-from-suggestions (stream, partial-completers: #(' ', '-'))
  for (command in commands)
    suggest (command, command-name (command))
  end for;
end completing-from-suggestions;
</pre>
      <a name="HEADING-86-113"></a>
      <h3 class="sub-subsection-title">Define Jump-instruction</h3>
      <pre class="code">
define macro jump-instruction-definer
  { define jump-instruction ?:name ?options:* end }
   =&gt; { register-instruction("j" ## ?#"name",
                             make(&lt;instruction&gt;,
                                  debug-name: "j" ## ?"name",
                                  ?options)) }
end macro;
define jump-instruction eq cr-bit: 2, commutative?: #t end;
</pre>
      <p><a name="IX-1304"></a><a name="IX-1305"></a></p>
      <a name="LINK-Macros-lastpage"></a><a name="LINK-Built-in_ClassesTOC-firstpage"></a><a name="UID-Built-in_ClassesTOC-2080"></a>
      <a name="LINK-Built-in_ClassesTOC-lastpage"></a>
    </div>

    <div id="footer">

      <hr />
      <address>The Dylan Reference Manual - 7 Apr 1998</address>
      <p id="navigation-footer">
	<a class="previous" accesskey="p" title="Previous Page" href="Hygiene"><span>&larr; Previous</span></a>
	<a class="next" accesskey="n" title="Next Page" href="Built-In_Classes"><span>Next Page &rarr;</span></a>
	<a class="up" accesskey="u" title="Chapter Start" href="Macros"><span>Up</span></a>
	<a class="start" accesskey="s" title="Start of Book" href="Title"><span>Start</span></a>
	<a class="contents" accesskey="c" title="Contents" href="Contents"><span>Contents</span></a>
	<a class="index" accesskey="i" title="Index" href="Index"><span>Index</span></a>
      </p>
      <p>Copyright Apple Computer, Inc. 1996. Apple&reg; and the Apple logo are registered
	trademarks of Apple Computer, Inc. Used with permission. All Rights Reserved.</p>
      <p>Originally generated with Harlequin WebMaker&reg;, subsequently revised.</p>
    </div>
  </body>
</html>
